from Crypto.Util.number import inverse, long_to_bytes
from sympy import nextprime
import math

# Example values for n, e, and c from the challenge output
n = 19863034877798345965277920400162420854443721380355808586602762628572371063518394849767433012436451934971247084770664520740745300267051598745728963333197550351338477656299403919838653794375281610864554812062488318854371156400919761162982390782383466375998143573974413524171224807790572480659669838414587471981273917460862625872662112934243648338649533346230657790246279637341370503085607096310775300438720406474809582576131089992851031973076280672105763610690429914645923855340081829261842927567646235641890815777467308233674432745148348362268683910562383700033733463389338624851407590677472351928339472185256004040657
e = 65537
c = 17766803113389982780819433274960885186650409736312242807168309159058064732240407133762940588816412263643457637118509637257242134521893396105812226637580484108733190546003430130641486046920539066158172819189364970545284280508063715889262003615982206307883810679243372381366514913175373640163875503985441066590394752132182850859263556327182212843476571359125096141468414513760423765580015963904022891828221723521846742019187170496544913286175376377822420085073801092584300369599721088377777673803666418050367505334807040994034929868133459570558110545120895789401240940509589095320941211728108500179660098074055174380578

def decrypt_rsa(n, e, c):
    # Try to find p and q by exploiting the fact that p and q are very close to each other.
    
    # Start by approximating the square root of n
    root_n = int(math.isqrt(n))
    
    # Try a wider search range for p and q
    search_range = 1000  # Increase this range to search more values
    
    # Try to find factors of n by checking numbers around root_n
    for i in range(root_n - search_range, root_n + search_range):  # Expand the search range
        if n % i == 0:
            p = i
            q = n // p
            break
    else:
        raise ValueError("Failed to factor n.")

    # Calculate φ(n) = (p-1) * (q-1)
    phi_n = (p - 1) * (q - 1)

    # Compute d, the modular inverse of e mod φ(n)
    d = inverse(e, phi_n)

    # Decrypt the ciphertext c using d
    m = pow(c, d, n)

    # Convert the decrypted message back to bytes (flag)
    flag = long_to_bytes(m).decode()
    return flag

# Decrypt the ciphertext
flag = decrypt_rsa(n, e, c)
print("Flag:", flag)

